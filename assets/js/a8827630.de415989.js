"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[518],{4438:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return u},toc:function(){return p},default:function(){return m}});var i=n(7462),a=n(3366),r=(n(7294),n(3905)),o=["components"],l={sidebar_position:2.5},s="Writing Types",u={unversionedId:"Types",id:"Types",isDocsHomePage:!1,title:"Writing Types",description:"Writing types is an important part of using Moonwave. Types are used everywhere that you document something: a parameter type, a return type, a type alias, etc.",source:"@site/docs/Types.md",sourceDirName:".",slug:"/Types",permalink:"/moonwave/docs/Types",editUrl:"https://github.com/evaera/moonwave/edit/master/website/docs/Types.md",tags:[],version:"current",lastUpdatedBy:"aku",lastUpdatedAt:1646882204,formattedLastUpdatedAt:"3/9/2022",sidebarPosition:2.5,frontMatter:{sidebar_position:2.5},sidebar:"defaultSidebar",previous:{title:"List of Tags",permalink:"/moonwave/docs/TagList"},next:{title:"Docs, Blog and Custom Pages",permalink:"/moonwave/docs/Docs"}},p=[{value:"Arrow functions",id:"arrow-functions",children:[{value:"Optional function arguments",id:"optional-function-arguments",children:[]}]},{value:"Arrays",id:"arrays",children:[]},{value:"Union types",id:"union-types",children:[]},{value:"Generics",id:"generics",children:[{value:"Type variable convention",id:"type-variable-convention",children:[]}]}],d={toc:p};function m(e){var t=e.components,n=(0,a.Z)(e,o);return(0,r.kt)("wrapper",(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"writing-types"},"Writing Types"),(0,r.kt)("p",null,"Writing types is an important part of using Moonwave. Types are used everywhere that you document something: a parameter type, a return type, a type alias, etc. "),(0,r.kt)("p",null,"In general, you should refer to the ",(0,r.kt)("a",{parentName:"p",href:"https://luau-lang.org/typecheck"},"Luau Typechecking Guide"),". Anything that's valid in a type position there should work in Moonwave."),(0,r.kt)("p",null,"Here are some important notes:"),(0,r.kt)("h2",{id:"arrow-functions"},"Arrow functions"),(0,r.kt)("p",null,"The syntax for a function type is a parenthesized list of arguments, followed by an arrow ",(0,r.kt)("inlineCode",{parentName:"p"},"->"),", followed by a parenthesized list of return types."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"(firstArg: number, secondArg: string) -> (string, number)"))),(0,r.kt)("p",null,"Functions with a single return value can omit the parentheses: "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"(firstArg: number, secondArg: string) -> string"))),(0,r.kt)("p",null,"Functions that return nothing should be denoted with a set of empty parentheses:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"(firstArg: number, secondArg: string) -> ()"))),(0,r.kt)("p",null,"So, a function that takes no arguments and returns nothing would look like:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"() -> ()"))),(0,r.kt)("h3",{id:"optional-function-arguments"},"Optional function arguments"),(0,r.kt)("p",null,"Optional functional arguments can be denoted with either a union of a type and nil, or by putting a question mark after the argument name or type."),(0,r.kt)("p",null,"These are equivalent:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"(arg: string | nil) -> ()")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"(arg?: string) -> ()")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"(arg: string?) -> ()"))),(0,r.kt)("h2",{id:"arrays"},"Arrays"),(0,r.kt)("p",null,"Arrays should be denoted by surrounding any other type with curly braces."),(0,r.kt)("p",null,"An array of strings would be ",(0,r.kt)("inlineCode",{parentName:"p"},"{string}"),". An array of numbers is ",(0,r.kt)("inlineCode",{parentName:"p"},"{number}"),"."),(0,r.kt)("h2",{id:"union-types"},"Union types"),(0,r.kt)("p",null,"When multiple types are valid, you can separate them with the pipe character ",(0,r.kt)("inlineCode",{parentName:"p"},"|"),"."),(0,r.kt)("p",null,"A function that takes a number or string and returns a string or boolean:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"(arg: number | string) -> string | boolean"))),(0,r.kt)("p",null,"An array of either numbers or nil:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"{number | nil}"))),(0,r.kt)("h2",{id:"generics"},"Generics"),(0,r.kt)("p",null,"Generic types can be used by denoting type variables between angled brackets."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"<T>(arg: T) -> (T, T)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"() -> Promise<T>"))),(0,r.kt)("p",null,"The types do not necessarily need to be valid Luau types. For example, you may omit declaring ",(0,r.kt)("inlineCode",{parentName:"p"},"<T>")," in a function, like so:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"(arg: T) -> (T, T)")," (note: missing ",(0,r.kt)("inlineCode",{parentName:"li"},"<T>")," at the beginning)")),(0,r.kt)("p",null,"Docs are for reading, not running, so if you think omitting information will make your type more clear, go for it."),(0,r.kt)("h3",{id:"type-variable-convention"},"Type variable convention"),(0,r.kt)("p",null,"In general, you can use ",(0,r.kt)("inlineCode",{parentName:"p"},"T"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"U"),", or any other single capital letter in any type position to constrain two types into being the same, without necessarily prescribing what that type is."),(0,r.kt)("p",null,"You could write a function type like so:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"(arg: T) -> T"))),(0,r.kt)("p",null,"Which means: A function that takes any type, but whatever type you give it, that's the type that will be returned."),(0,r.kt)("p",null,"This is different from ",(0,r.kt)("inlineCode",{parentName:"p"},"(arg: any) -> any"),", because in that case, the function doesn't necessarily have to return the same type that is passed in, you could return anything. But by specifying ",(0,r.kt)("inlineCode",{parentName:"p"},"T")," in both places, you're indicating that the two types are the same, whatever they might be. "),(0,r.kt)("p",null,"For an example of this, check out the ",(0,r.kt)("a",{parentName:"p",href:"https://eryn.io/roblox-lua-promise/api/Promise#fold"},"Promise.fold")," docs."))}m.isMDXComponent=!0}}]);