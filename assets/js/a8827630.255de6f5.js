"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[595],{8541:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"Types","title":"Writing Types","description":"Writing types is an important part of using Moonwave. Types are used everywhere that you document something: a parameter type, a return type, a type alias, etc.","source":"@site/docs/Types.md","sourceDirName":".","slug":"/Types","permalink":"/moonwave/docs/Types","draft":false,"unlisted":false,"editUrl":"https://github.com/evaera/moonwave/edit/master/website/docs/Types.md","tags":[],"version":"current","lastUpdatedBy":"aku","lastUpdatedAt":1646882204000,"sidebarPosition":2.5,"frontMatter":{"sidebar_position":2.5},"sidebar":"defaultSidebar","previous":{"title":"List of Tags","permalink":"/moonwave/docs/TagList"},"next":{"title":"Docs, Blog and Custom Pages","permalink":"/moonwave/docs/Docs"}}');var r=i(4848),s=i(8453);const o={sidebar_position:2.5},a="Writing Types",l={},c=[{value:"Arrow functions",id:"arrow-functions",level:2},{value:"Optional function arguments",id:"optional-function-arguments",level:3},{value:"Arrays",id:"arrays",level:2},{value:"Union types",id:"union-types",level:2},{value:"Generics",id:"generics",level:2},{value:"Type variable convention",id:"type-variable-convention",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"writing-types",children:"Writing Types"})}),"\n",(0,r.jsx)(n.p,{children:"Writing types is an important part of using Moonwave. Types are used everywhere that you document something: a parameter type, a return type, a type alias, etc."}),"\n",(0,r.jsxs)(n.p,{children:["In general, you should refer to the ",(0,r.jsx)(n.a,{href:"https://luau-lang.org/typecheck",children:"Luau Typechecking Guide"}),". Anything that's valid in a type position there should work in Moonwave."]}),"\n",(0,r.jsx)(n.p,{children:"Here are some important notes:"}),"\n",(0,r.jsx)(n.h2,{id:"arrow-functions",children:"Arrow functions"}),"\n",(0,r.jsxs)(n.p,{children:["The syntax for a function type is a parenthesized list of arguments, followed by an arrow ",(0,r.jsx)(n.code,{children:"->"}),", followed by a parenthesized list of return types."]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"(firstArg: number, secondArg: string) -> (string, number)"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Functions with a single return value can omit the parentheses:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"(firstArg: number, secondArg: string) -> string"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Functions that return nothing should be denoted with a set of empty parentheses:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"(firstArg: number, secondArg: string) -> ()"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"So, a function that takes no arguments and returns nothing would look like:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"() -> ()"})}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"optional-function-arguments",children:"Optional function arguments"}),"\n",(0,r.jsx)(n.p,{children:"Optional functional arguments can be denoted with either a union of a type and nil, or by putting a question mark after the argument name or type."}),"\n",(0,r.jsx)(n.p,{children:"These are equivalent:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"(arg: string | nil) -> ()"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"(arg?: string) -> ()"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"(arg: string?) -> ()"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"arrays",children:"Arrays"}),"\n",(0,r.jsx)(n.p,{children:"Arrays should be denoted by surrounding any other type with curly braces."}),"\n",(0,r.jsxs)(n.p,{children:["An array of strings would be ",(0,r.jsx)(n.code,{children:"{string}"}),". An array of numbers is ",(0,r.jsx)(n.code,{children:"{number}"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"union-types",children:"Union types"}),"\n",(0,r.jsxs)(n.p,{children:["When multiple types are valid, you can separate them with the pipe character ",(0,r.jsx)(n.code,{children:"|"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"A function that takes a number or string and returns a string or boolean:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"(arg: number | string) -> string | boolean"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"An array of either numbers or nil:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"{number | nil}"})}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"generics",children:"Generics"}),"\n",(0,r.jsx)(n.p,{children:"Generic types can be used by denoting type variables between angled brackets."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"<T>(arg: T) -> (T, T)"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"() -> Promise<T>"})}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The types do not necessarily need to be valid Luau types. For example, you may omit declaring ",(0,r.jsx)(n.code,{children:"<T>"})," in a function, like so:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"(arg: T) -> (T, T)"})," (note: missing ",(0,r.jsx)(n.code,{children:"<T>"})," at the beginning)"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Docs are for reading, not running, so if you think omitting information will make your type more clear, go for it."}),"\n",(0,r.jsx)(n.h3,{id:"type-variable-convention",children:"Type variable convention"}),"\n",(0,r.jsxs)(n.p,{children:["In general, you can use ",(0,r.jsx)(n.code,{children:"T"}),", ",(0,r.jsx)(n.code,{children:"U"}),", or any other single capital letter in any type position to constrain two types into being the same, without necessarily prescribing what that type is."]}),"\n",(0,r.jsx)(n.p,{children:"You could write a function type like so:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"(arg: T) -> T"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Which means: A function that takes any type, but whatever type you give it, that's the type that will be returned."}),"\n",(0,r.jsxs)(n.p,{children:["This is different from ",(0,r.jsx)(n.code,{children:"(arg: any) -> any"}),", because in that case, the function doesn't necessarily have to return the same type that is passed in, you could return anything. But by specifying ",(0,r.jsx)(n.code,{children:"T"})," in both places, you're indicating that the two types are the same, whatever they might be."]}),"\n",(0,r.jsxs)(n.p,{children:["For an example of this, check out the ",(0,r.jsx)(n.a,{href:"https://eryn.io/roblox-lua-promise/api/Promise#fold",children:"Promise.fold"})," docs."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var t=i(6540);const r={},s=t.createContext(r);function o(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);